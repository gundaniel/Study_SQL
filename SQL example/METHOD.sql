--많이 사용하는 함수
--------------------삭제----------------------------
--테이블을 삭제
/*
DELETE TABLE 테이블이름;
*/

--칼럼을 삭제
/*
ALTER TABLE 테이블이름
DROP COLUMN 칼럼이름;
*/

--레코드를 삭제
/*
DELETE FROM 테이블이름
WHERE 조건(중복되지 않은 값);
*/
---------------------------------------------------
--------------------수정----------------------------
--칼럼명을 수정
/* 
ALTER TABLE 테이블 이름
RENAME( 바뀔 칼럼이름(OLD) TO 바꿀 칼럼이름(NEW));
*/

--칼럼을 수정(데이터 타입, 값,크기 수정)
/*
ALTER TABLE 테이블 이름
MODIFY(칼럼이름 바꿀값(타입,크기) );
*/

--테이블의 내용을 수정
/*
UPDATE 테이블이름
SET 칼럼이름 = 값 , 칼럼이름 = 값.... (바꿀 값)
WHERE 조건(바꿔질 값);
*/
---------------------------------------------------
--------------------생성----------------------------
--테이블을 생성
/*
CREATE TABLE 테이블 이름(
칼럼이름1 칼럼타입(값) NOT NULL등...,
칼럼이름2 칼럼타입(값) NOT NULL등...,
);
*/
--테이블의 내용을 생성
/*
INSERT INTO 테이블이름(컬럼1,컬럼2,컬럼3...)
VALUES(값1,값2,값3)

컬럼1 = 값1 
컬럼2 = 값2
컬럼3 = 값3
*/
---------------------------------------------------
---------------------------------------------------
--시퀀스 생성
--시퀸스는 PRIMARY KEY에 일련번호를 자동부여함 (유일값을 생성해주는 오라클 객체(순차적으로 생성)
--CREATE SEQUENCE test_seq START WITH 1  --1부터 시작
--INCREMENT BY 1 --1개 증가f
--MINVALUE 1 --최솟값 1
--MAXVALUE 999999 --최댓값
--NOCYCLE --반복없음
--CACHE 2; -- 2값을 저장
---------------------------------------------------
--시퀀스 삭제
--DROP SEQUENCE 시퀀스명;
---------------------------------------------------
--GENERATED 컬럼: 테이블에 있는 컬럼을 기반으로 하여 계산된 값을 저장할 수 있는 컬럼
--형식 : 컬럼 데이터 타입 generated always as (계산식) vurturl
---------------------------------------------------
--오라클에서 IDENTITY는 주로 테이블의 기본 키(PK)를 생성할 때 사용되는 제어자.
--이 제어자를 사용하면 오라클이 자동으로 증가하는 값을 기본 키로 할당하게 된다.
--형식: 컬럼 number generated by depault as identity
---------------------------------------------------
---------------------------------------------------
--1일을 초로환산하는 계산식 출력 =테이블 로우의 개수(27개)가 모두 출력됨

SELECT 24*60*60
FROM DEPARTMENTS;

--DUAL 칼럼을 사용하면 X라는 1개의 문자밖에 없으므로 반환이 1번만 됨

SELECT 24*60*60
FROM DUAL;

DESC DUAL; --DUMMY값이 들어가있음
--함수확인시 용이하게 사용★
----------------------------------------
--<예> 30번 부서 소속 사원의 급여를 출력하는 쿼리문
SELECT * FROM EMPLOYEES;

SELECT DEPARTMENT_ID , SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;
----------------------------------------
--<예> 그룹함수를 이용해서 부서별 사원들의 급여의 합을 구하는 쿼리문
SELECT DEPARTMENT_ID , SUM(SALARY) --SUM 사용
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID --GROUP BY사용
ORDER BY DEPARTMENT_ID ASC;

----------------------------------------
--<예> 위의 쿼리문에서 30번 부서에 소속된 사원들의 총급여를 구하는 쿼리문
--그룹함수를 사용했기 때문에 6개의 행에 대하여 하나의 행으로 나옴
SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID=30
GROUP BY DEPARTMENT_ID;
----------------------------------------
--단일 행 함수 = ROUND(SAL, -3) (행마다 함수가 적용되어 결과를 반환(행 별로)
/*
SUM = 그룹의 합계
AVG = 그룹의 평균
COUNT = 그룹의 총 개수
MAX = 그룹의 최댓값
MIN = 그룹의 최솟값
STDDEV = 그룹의 표준편차(분산 값의 제곱근)
VARIANCE = 그룹의 분산(범위의 개별값 - 평균값사이의 편차 )*제곱 = 평균 값
*/
----------------------------------------

SELECT 'DATEBASE', --문자 추출 반환
LOWER('DATEBASE'), --소문자로 변환 (대문자는 UPPER)
INITCAP('DATEBASE'), --첫글자는 대문자, 나머지는 소문자 변호나
CONCAT('DATA',' BASE') --문자를 연결
FROM DUAL;


--한글은 UTF-8에서 3바이트
SELECT '데이터베이스', --글자는 공백을 포함함
SUBSTR('데이터베이스',3), --앞에서 3번째부터 반환(순서) (한글 1BYTE)
SUBSTRB('데이터베이스',3), --앞에서 2번째부터 반환(크기) (한글 2BYTE)
LENGTH('데이터베이스'), --문자의 길이를 반환(개수)6
LENGTHB('데이터베이스')  --문자의 길이를 반환(크기?)18
FROM DUAL;

SELECT '데이터베이스',
INSTR('데이터베이스','이'), -- 순서를 반환(2)
INSTRB('데이터베이스','이') -- 

FROM DUAL;







