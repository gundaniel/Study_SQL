--조인 = 한개이상의 테이블에서 원하는 결과를 얻기 위한 조인을 학습한다. 

-- *inner join* 
-- equi join 동일 칼럼을 기준으로 조인 "=" 연산자를 사용
-- non-equi join 동일칼럼이 없이 다른 조건을 사용하여 조인한다. "="외에 비교연산자를 사용

SELECT *FROM EMPLOYEES, DEPARTMENTS;

SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES;


-- equi join(inner join)
-- 오라클전용 SELECT 컬럼, FROM 테이블 명, 테이블명 WHERE  JOIN 조건문.
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

-- 조인시 공동컬럼을 조회하고자 할때는 반드시 테이블명.컬럼 또는 테이블 별칭.컬럼으로 명시
-- ORA-00918: 열의 정의가 애매합니다 = DEPARTMENT_ID -> 양쪽의 컬럼이 둘다있어서 어느것을참조할 지 애매해짐
SELECT FIRST_NAME, DEPARTMENT_NAME, DEPARTMENT_ID
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

-- 해결 = EMPLOYEES.DEPARTMENT_ID 참조한다는 것을 명시
SELECT FIRST_NAME, DEPARTMENT_NAME, EMPLOYEES.DEPARTMENT_ID
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

SELECT FIRST_NAME, DEPARTMENT_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.FIRST_NAME = 'Susan';

--------------------------------------------------------------------------------------------
-- <문제>사원명, 직무ID, 직무명(JOB_TITLE), 부서번호, 부서명을 출력해 주세요.
SELECT * FROM EMPLOYEES;
SELECT * FROM JOBS;
SELECT * FROM DEPARTMENTS;

SELECT FIRST_NAME, J.JOB_ID, JOB_TITLE, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM JOBS J, EMPLOYEES E, DEPARTMENTS D
WHERE J.JOB_ID = E.JOB_ID AND E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--------------------------------------------------------------------------------------------
--NON-EQUI JOIN 예제

--테이블 생성
CREATE TABLE SALARYGRADE(
GRADE NUMBER,
MINSALARY NUMBER,
MAXSALARY NUMBER
);
--데이터 삽입
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(1,2000,3000);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(2,3001,4500);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(3,4501,6000);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(4,6001,8000);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(5,8001,10000);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(6,10001,13000);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(7,13001,20000);
INSERT INTO SALARYGRADE (GRADE,MINSALARY,MAXSALARY)VALUES(8,20001,30000);

SELECT * FROM SALARYGRADE;

COMMIT;

--EMPLOYEES 테이블과 조인하여 사원의 등급을 지정
SELECT E.FIRST_NAME, E.SALARY,S.GRADE
FROM EMPLOYEES E,SALARYGRADE S
WHERE E.SALARY BETWEEN S.MINSALARY AND S.MAXSALARY; --MIN과 MAX 사이에 있는 E.SALARY를 출력

/*
--다른방식으로 출력
SELECT E.FIRST_NAME, E.SALARY, S.GRADE
FROM EMPLOYEES E,SALARYGRADE S
WHERE E.SALARY >= S.MINSALARY AND E.SALARY <= S.MAXSALARY;
*/
--------------------------------------------------------------------------------------------
--OUTER JOIN 예제

--사원테이블 과 부서 테이블을 조인하여 사원이름과 부서번호와 부서명을 출력
---OUTER JOIN (+) 기호 사용 = 정보가 부족한 칼럼명 뒤에 붙임

--INNER JOIN
SELECT FIRST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID; --(+)가 없음

--OUTRT JOIN
SELECT FIRST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;  --(+)가 있음

--------------------------------------------------------------------------------------------

--<문제> 2007년도 상반기에 입사한 사원의 사언번호, 이름, 입사일, 부서번호를 구해보자
--(결과 행의 수 :12)
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, DEPARTMENT_ID
FROM EMPLOYEES 
WHERE HIRE_DATE BETWEEN '2007/01/01' AND '2007/06/30';


--<문제> 2007년도 상반기에 입사한 사원의 사원번호, 이름, 입사일, 부서명을 출력.
--(결과 행의 수 :11) -INNER JOIN
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND HIRE_DATE BETWEEN '2007/01/01' AND '2007/06/30';

--(결과 행의 수 :12) -OUTER JOIN
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
AND HIRE_DATE BETWEEN '2007/01/01' AND '2007/06/30';
--------------------------------------------------------------------------------------------
--SELF JOIN 예제

--★문자 함수★
--SELECT RPAD(WORK.FIRST_NAME(컬럼명),11(자리수),' '(자리수가 되지 않았을때 체울문자));

SELECT WORK.FIRST_NAME "사원명", MANAGER.FIRST_NAME AS "매니저명"
FROM EMPLOYEES WORK, EMPLOYEES MANAGER
WHERE WORK.MANAGER_ID = MANAGER.EMPLOYEE_ID;

--사원 테이블
SELECT EMPLOYEE_ID, FIRST_NAME, MANAGER_ID
FROM EMPLOYEES;
--관리자 테이블
SELECT EMPLOYEE_ID,FIRST_NAME
FROM EMPLOYEES ORDER BY EMPLOYEE_ID;

SELECT WORK.FIRST_NAME "사원명", MANAGER.FIRST_NAME AS "매니저명"
FROM EMPLOYEES WORK, EMPLOYEES MANAGER
WHERE WORK.MANAGER_ID = MANAGER.EMPLOYEE_ID
ORDER BY EMPLOYEE_ID;

SELECT RPAD(WORK.FIRST_NAME,11,' ') ||'의 매니저는 ' || MANAGER.FIRST_NAME || '입니다'
AS "그 사원의 매니저"
FROM EMPLOYEES WORK, EMPLOYEES MANAGER
WHERE WORK.MANAGER_ID = MANAGER.EMPLOYEE_ID;


--------------------------------------------------------------------------------------------

--INNER JOIN
--JOIN만 작성시 기본값은 INNER JOIN
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

--사원테이블과 직무테이블 -> 공통칼럼 = JOB_ID
--사원테이블과 부서테이블 -> 공통칼럼 = DEPARTMENT_ID
--사원명, 직무ID, 직무명(JOB_TITLE), 부서번호, 부서명을 출력해주세요

SELECT E.FIRST_NAME, E.JOB_ID, J.JOB_TITLE, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN JOBS J ON E.JOB_ID = J.JOB_ID
INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

--조인의 조건과 데이터 검색을 위한 조건 부여
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE FIRST_NAME = 'Susan';

-- 연결에 사용하려는 컬럼명이 같은 경우 USING() 사용, 다른 경우 ON()사용
SELECT EMPLOYEES.FIRST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
USING (DEPARTMENT_ID);


-- USING사용시 테이블 명이나 별칭을 붙이지 않음(공통되는 칼럼을 불러오기 때문에)
SELECT FIRST_NAME, DEPARTMENT_NAME ,DEPARTMENT_ID
FROM EMPLOYEES INNER JOIN DEPARTMENTS
USING (DEPARTMENT_ID);

--OUTER JOIN
--가져올 테이블 기준으로 LDRF, PIGHT 명시
SELECT EMPLOYEES.FIRST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES LEFT OUTER JOIN DEPARTMENTS
USING (DEPARTMENT_ID);

SELECT EMPLOYEES.FIRST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES RIGHT OUTER JOIN DEPARTMENTS
USING (DEPARTMENT_ID);

SELECT EMPLOYEES.FIRST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE HIRE_DATE BETWEEN '2007.01.01' AND '2007.01.01';

---------------------------------------------------------------------------
--부서명으로 조건부여
SELECT* FROM DEPARTMENTS;

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, E.DEPARTMENT_ID, DEPARTMENT_NAME, SALARY,
CASE DEPARTMENT_NAME 
WHEN 'Marketing' THEN SALARY * 1.05
WHEN 'Purchasing' THEN SALARY * 1.1
WHEN 'Human Resources' THEN SALARY * 1.15
WHEN 'IT' THEN SALARY * 1.2 
ELSE SALARY
END UPSALARY
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID;
---------------------------------------------------------------------------
--1. Sales 부서 소속 사원의 이름과 입사일을 출력하라

SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
on E.DEPARTMENT_ID = D.DEPARTMENT_ID AND DEPARTMENT_NAME = 'Sales';
---------------------------------------------------------------------------
--2. 커미션을 받는 사원의 이름, 커미션 비율과 그가 속한 부서명을 출력하라. 
select FIRST_NAME, COMMISSION_PCT, DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
on E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE COMMISSION_PCT IS NOT NULL;

---------------------------------------------------------------------------
--EMPLOYEES 테이블에서 부서인원이 5명보다 많은 부서의 부서번호,부서명, 인원수, 급여의 합을 출력
--4. 사원수가 5명 이상인 부서의 부서명과 사원수를 출력하시오. 이때 사원수가 많은 순으로 정렬하시오.

SELECT * FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;

SELECT E.DEPARTMENT_ID AS 부서번호 , DEPARTMENT_NAME AS 부서명, COUNT(E.EMPLOYEE_ID) AS 인원수 , SUM(SALARY) AS 급여합계
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY E.DEPARTMENT_ID, DEPARTMENT_NAME
HAVING COUNT(E.EMPLOYEE_ID) >= 5 --그룹함수 사용은 WHERE가 아닌 HAVING 사용
ORDER BY COUNT(EMPLOYEE_ID) DESC;
--ORDER BY 3 DESC;






